\section{Refinement Awareness}

One of the biggest differences between attack trees and other tree-like data structures is the presence of refinements, or the \AND\ and \OR\ relationships, which state whether all of the children of a node must be satisfied for the parent node to be satisfiable (\AND) or if at least one must be satisfied for a parent node to be satisfiable (\OR).

The presence of refinements in a tree does not significantly complicate the calculation of tree edit distance. As given by RTED?, the tree edit distance can be given by the summation: \NS{include the nice summation from whatever paper I think I saw it in}.

In the Zhang and Shasha algorithm there are three possibilities for nodes, (i) a node must be added, (ii) a node must be removed, or (iii) a node must be replaced~\cite{zhang_simple_1989}, this is described as $\text { forestdist }\left(l\left(i_1\right) \ldots i, l\left(j_1\right) . . j\right)$. We give the cost of this change is given to be $\gamma(\Delta)$, then this cost would likewise need to be applied to all three cases. However, we find the following:

% Write a latex lemma environment in which the lemma shows that for the node removal case, there is no additional cost for changing a refinement, for the adding case, the cost of adding a refinment would be included in the cost of adding the node, and subsequently, the cost of replacing a node would have only the \gamma(\Delta)

\begin{definition} \label{def:attack-tree} Let $T$ be an attack tree with $T = t\Delta(t_1,...,t_n)$ where $T = b|T\Delta(T[0],...,T[i])$ and $\Delta = \AND|\OR$. We give $b$ to be some action within the attack scenario. Let $\gamma$ be the cost function for the tree edit distance, with the cost of removing a subtree to be $\gamma(T_1[i] \rightarrow {\Lambda})$, the cost of adding a subtree to be $\gamma({\Lambda}\rightarrow T_1[i])$, and the cost of changing a subtree to be $\gamma(T_1[i] \rightarrow T_2[j])$. We give the cost changing a refinement for subtrees $T_1[i]$ and $T_2[j]$ to be $\gamma(\Delta_1[i] \rightarrow \Delta_2[j])$. To simplify changing refinements, as only two refinements are given, we say the cost of changing a refinement to be $\gamma(\Delta)$.  Given the above, we have the following:

\begin{enumerate} 
\item In the case of node removal, there can be no additional cost for changing a refinement. That is, if we remove a node $T_2[j]$ from $T$, then we have:

$$\gamma(T_2[j] \rightarrow {\Lambda})$$

            $\Lambda$ is an empty tree, and by definition does not contain any refinements. Therefore, the cost of changing the refinement is zero.

\item In the case of adding a node, the cost of adding a refinement would be included in the cost of adding the node. That is, if we add a node $T_2[j]$ to $T$, then we have:

$$\gamma(\Lambda \rightarrow {T_2[j]})$$

It is not possible to for a node in an attack tree to not have a refinement. If we separate the cost of adding a node and the cost of adding a refinement, we have one of the two following cases:
\begin{enumerate}
      \item A node is added without a refinement, which gives a refinement addition cost of 0, but results in an attack tree which is not valid given our attack tree definition.
      \item The cost of adding a refinement is \textbf{always} added to the cost of adding a node, which results in the new cost of adding a node to always include $\gamma(\Delta)$.
\end{enumerate}

Given one of these cases results in an invalid tree, the other case must always apply. Therefore, by convention, we do not separate the cost of adding a node and the cost of adding a refinement, these are one and the same.

      \item In the case of replacing a node, the cost of replacing a refinement would be:

$$\gamma({T_1[i]} \rightarrow {T_2[j]})$$

Which we declare to consist of the sum following two costs:

$$\gamma({T_1[i].\text{label}} \rightarrow {T_2[j].\text{label}})$$

Which is the cost of changing one label to another. This is the original cost of replacing a node according to Zhang-Shasha. We also have:

$$\gamma(\Delta)$$

Which as previously stated is the cost of changing a refinement.



\end{enumerate}

\end{definition}


\begin{lemma}
Let $T$ be some attack tree within the definition of Definition~\ref{def:attack-tree}. It must be the case that

\[\gamma(\Delta) < \gamma(T_2[j] \rightarrow {\Lambda}) + \gamma(\Lambda \rightarrow {T_2[j]})\]

\begin{proof}
      test
\end{proof}


\end{lemma}


% \begin{multline*}
% \text { forestdist }\left(l\left(i_1\right) \ldots i, l\left(j_1\right) . . j\right)
% \\
% \text{  }\text{  }\text{  }=\min \left\{\begin{array}{l}
%         \text { forestdist }\left(l\left(i_1\right) \ldots i-1, l\left(j_1\right) . . j\right)+\gamma\left(T_1[i] \rightarrow \Lambda\right), \\
%         \text { forestdist }\left(l\left(i_1\right) . . i, l\left(j_1\right) . . j-1\right)+\gamma\left(\Lambda \rightarrow T_2[j]\right),    \\
%         \text { forestdist }\left(l\left(i_1\right) . . l(i)-1, l\left(j_1\right) . . l(j)-1\right)                                           \\
%         + \text { forestdist }(l(i) \ldots i-1, l(j) . . j-1)                                                                                 \\
%         +\gamma\left(T_1[i] \rightarrow T_2[j]\right) .
%     \end{array}\right.
% \end{multline*}




As the cost of replacing refinements is ever present, we can simply apply the cost of the replacing refinements after computing the tree edit distance by following the mappings and subsequently applying changed refinements. By doing this, we do not add to the time complexity of the Zhang and Shasha algorithm.

This method of computation works as it is not possible to have an intermediate attack tree node without a refinement~\cite{mauw_foundations_2006}. As such, all non-leaf nodes are either \AND\ or \OR\ nodes, so the distance between refinements is simple given as the cost needed to convert from one refinement to the other. As unlike the calculations of adding ($\Lambda \rightarrow i$), removing ($i \rightarrow \Lambda$), or replacement ($i \rightarrow j$), with refinements there is only on possible operation: replacement. Either \AND $\rightarrow$ \OR\ or \OR $\rightarrow$ \AND.

Similarly, \NS{the binary trees people}

Critically, this methodology can only work so long as the order of the nodes does not carry any significance (\textit{i.e} the nodes can be reordered without issue). There is an extention of attack trees which adds a sequential \AND\ (\SAND) refinement, in which the nodes in a \SAND\ relationship are given to be ordered~\cite{jhawar_attack_2015}; however, this is out of scope for our purposes. We discuss this further in Section~\NS{ref future work}.