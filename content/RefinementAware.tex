\section{Refinement Awareness}

One of the biggest differences between attack trees and other tree-like data structures is the presence of refinements, or the \AND\ and \OR\ relationships, which state whether all of the children of a node must be satisfied for the parent node to be satisfiable (\AND) or if at least one must be satisfied for a parent node to be satisfiable (\OR). This is a critical part of the attack tree structure and must be included in the tree edit distance algorithm.




\begin{definition}\label{def:cost-function}
Similar to Zhang and Shasha, we define $\gamma$ be the cost function for the node edit distance, with the cost of removing a node to be $\gamma(T_1[i] \rightarrow {\Lambda})$, the cost of adding a node to be $\gamma({\Lambda}\rightarrow T_1[i])$, and the cost of changing a node to be $\gamma(T_1[i] \rightarrow T_2[j])$. We give the cost changing a refinement for node  $T_1[i]$ and $T_2[j]$ to be $\gamma(\Delta_1[i] \rightarrow \Delta_2[j])$. To simplify changing refinements, as only two refinements are given, we say the cost of changing a refinement to be $\gamma(\Delta)$. That is to say $\gamma(\AND \rightarrow \OR) = \gamma(\OR \rightarrow \AND)$.
\end{definition}



\begin{lemma}\label{lem:gamma-delta}

      $\gamma(\Delta)$ only applies in the case of changing one node into another.

\begin{proof}
      

\begin{enumerate} 
\item In the case of node removal, there can be no additional cost for changing a refinement. That is, if we remove a node $T_2[j]$ from $T$, then we have:

$$\gamma(T_2[j] \rightarrow {\Lambda})$$

            $\Lambda$ is an empty tree, and by definition does not contain any refinements. Therefore, the cost of changing the refinement is zero.

\item In the case of adding a node, the cost of adding a refinement would be included in the cost of adding the node. That is, if we add a node $T_2[j]$ to $T$, then we have:

$$\gamma(\Lambda \rightarrow {T_2[j]})$$

It is not possible to for a node in an attack tree to not have a refinement. If we separate the cost of adding a node and the cost of adding a refinement, we have one of the two following cases:
\begin{enumerate}
      \item A node is added without a refinement, which gives a refinement addition cost of 0, but results in an attack tree which is not valid given our attack tree definition.
      \item The cost of adding a refinement is \textbf{always} added to the cost of adding a node, which results in the new cost of adding a node to always include $\gamma(\Delta)$.
\end{enumerate}

Given one of these cases results in an invalid tree, the other case must always apply. Therefore, by convention, we do not separate the cost of adding a node and the cost of adding a refinement, these are one and the same.

      \item In the case of replacing a node, the cost of replacing a refinement would be:

$$\gamma({T_1[i]} \rightarrow {T_2[j]})$$

Which we declare to consist of the sum following two costs:

$$\gamma({T_1[i].\text{label}} \rightarrow {T_2[j].\text{label}})$$

Which is the cost of changing one label to another. This is the original cost of replacing a node according to Zhang-Shasha. We also have:

$$\gamma(\Delta)$$

Which as previously stated is the cost of changing a refinement.



\end{enumerate}

\end{proof}

\end{lemma}




\begin{lemma}\label{lem:gamma-delta-2}
For attack trees within the definition of Definition~\ref{def:attack-tree}. It must be the case that

\[\gamma(\Delta) \le \gamma(T_2[j] \rightarrow {\Lambda}) + \gamma(\Lambda \rightarrow {T_2[j]})\]

\begin{proof}
Let $T$ be an attack tree.

Assume that $\gamma(\Delta) > \gamma(T_2[j] \rightarrow {\Lambda}) + \gamma(\Lambda \rightarrow {T_2[j]})$.

Let $S$ be the optimal sequence of edit operations according to the Zhang-Shasha algorithm. That is, $\gamma(S)$ is minimal for all possible edit sequences for $\delta(T_1, T_2)$ Let some operation $s \in S$ be an operation to replace some node, $T_1[i]$, with another, $T_2[j]$.

Thus, $\gamma(s) = \gamma({T_1[i].\text{label}} \rightarrow {T_2[j].\text{label}}) + \gamma(\Delta)$

We have two cases:

\begin{enumerate}
\item $T_1[i].\Delta = T_2[j].\Delta$ 

In this case, both $T_1[i]$ and $T_2[j]$ have the same refinement. Thus, $\gamma(\Delta) = 0$. Therefore, $\gamma(s) = \gamma({T_1[i].\text{label}} \rightarrow {T_2[j].\text{label}})$. 

\item $T_1[i].\Delta \ne T_2[j].\Delta$

In this case, both $T_1[i]$ and $T_2[j]$ have different refinements. Thus, $\gamma(\Delta) > 0$. Therefore, $\gamma(s) = \gamma({T_1[i].\text{label}} \rightarrow {T_2[j].\text{label}}) + \gamma(\Delta)$.

However, we have assumed that $\gamma(\Delta) > \gamma(T_2[j] \rightarrow {\Lambda}) + \gamma(\Lambda \rightarrow {T_2[j]})$. Therefore, $\gamma(s) = \gamma({T_1[i].\text{label}} \rightarrow {T_2[j].\text{label}}) + \gamma(\Delta) > \gamma(T_2[j] \rightarrow {\Lambda}) + \gamma(\Lambda \rightarrow {T_2[j]})$, as by convention $\gamma$ cannot result in a negative value.

As such, we can replace $s$ with the sequence of operations $s_1$ and $s_2$, where $s_1$ is the operation to remove $T_1[i]$ and $s_2$ is the operation to add $T_2[j]$. Thus, $\gamma(s_1) = \gamma(T_2[j] \rightarrow {\Lambda})$ and $\gamma(s_2) = \gamma(\Lambda \rightarrow {T_2[j]})$. Therefore, $\gamma(s_1) + \gamma(s_2) < \gamma(s)$.

This results in a contradiction, as $S$ is the optimal sequence of edit operations according to the Zhang-Shasha algorithm, it must not be possible to replace any $s \in S$ with an operation, or sequence of operations, with lower cost.
\end{enumerate}

Therefore, if $\gamma(\Delta) > \gamma(T_2[j] \rightarrow {\Lambda}) + \gamma(\Lambda \rightarrow {T_2[j]})$, then $\gamma(\Delta)$ either must be 0 for a change node edit operation to be included in the optimal sequence of edit operations (case 1), or the optimal sequence of edit operations must always result in node removal then replacement (case 2). In both cases, $\gamma(\Delta)$ is not used. 

Therefore, in order to include the cost of changing refinements in the cost of replacing a node, it must be the case that $\gamma(\Delta) \le \gamma(T_2[j] \rightarrow {\Lambda}) + \gamma(\Lambda \rightarrow {T_2[j]})$.


\end{proof}


\end{lemma}


% \begin{multline*}
% \text { forestdist }\left(l\left(i_1\right) \ldots i, l\left(j_1\right) . . j\right)
% \\
% \text{  }\text{  }\text{  }=\min \left\{\begin{array}{l}
%         \text { forestdist }\left(l\left(i_1\right) \ldots i-1, l\left(j_1\right) . . j\right)+\gamma\left(T_1[i] \rightarrow \Lambda\right), \\
%         \text { forestdist }\left(l\left(i_1\right) . . i, l\left(j_1\right) . . j-1\right)+\gamma\left(\Lambda \rightarrow T_2[j]\right),    \\
%         \text { forestdist }\left(l\left(i_1\right) . . l(i)-1, l\left(j_1\right) . . l(j)-1\right)                                           \\
%         + \text { forestdist }(l(i) \ldots i-1, l(j) . . j-1)                                                                                 \\
%         +\gamma\left(T_1[i] \rightarrow T_2[j]\right) .
%     \end{array}\right.
% \end{multline*}




As the cost of replacing refinements is ever present, we can simply apply the cost of the replacing refinements after computing the tree edit distance by following the mappings and subsequently applying changed refinements. By doing this, we do not add to the time complexity of the Zhang and Shasha algorithm.

This method of computation works as it is not possible to have an intermediate attack tree node without a refinement~\cite{mauw_foundations_2006}. As such, all non-leaf nodes are either \AND\ or \OR\ nodes, so the distance between refinements is simple given as the cost needed to convert from one refinement to the other. As unlike the calculations of adding ($\Lambda \rightarrow i$), removing ($i \rightarrow \Lambda$), or replacement ($i \rightarrow j$), with refinements there is only on possible operation: replacement: either \AND $\rightarrow$ \OR\ or \OR $\rightarrow$ \AND. 

There are attack trees which contain additional refinements such as \SAND\ refinements, which are sequential \AND\ refinements, that is \AND\ refinements where the order of nodes is significant \cite{jhawar_attack_2015}. While our work only focuses on attack trees with \AND\ and \OR\ refinements, if the cost of changing to and from \SAND\ refinements is given as equivalent to the cost of changing to and from \AND\ or \OR\ refinements, then our method can be trivially extended to include \SAND\ refinements. However, our study to validate our method does not include attack trees with sequential conjunction.

Similarly, \NS{the binary trees people}

% Critically, this methodology can only work so long as the order of the nodes does not carry any significance (\textit{i.e} the nodes can be reordered without issue). There is an extention of attack trees which adds a sequential \AND\ (\SAND) refinement, in which the nodes in a \SAND\ relationship are given to be ordered~\cite{jhawar_attack_2015}; however, this is out of scope for our purposes. We discuss this further in Section~\NS{ref future work}.