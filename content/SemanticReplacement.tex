\section{Semantic Label Replacement}

In tree edit distance, the replacement calculation is made when the root nodes of subtrees are not the same~\cite{zhang_simple_1989}. 


\tikzstyle{block} = [rectangle, draw, fill=black!290, 
    text width=5em, text=white,  text centered,  minimum height=4em]

    
\begin{figure*}
\begin{tikzpicture}[node distance = 2cm, auto]
    % Place nodes
    \node [xshift=-5cm](t1) {$T_1[i].\text{label}$};
    \node [below of = t1] (t2) {$T_2[j].\text{label}$};
    \node [block, below right = .5cm and 1cm of t1, yshift=.3cm]  (genbeddings) {\shortstack{Generate\\Semantic\\Embeddings}};
    \node [right of = t1, xshift=4cm]  (et1) {$\vec{e}(T_1[i].\text{label})$};
    \node [below of = et1]  (et2) {$\vec{e}(T_2[j].\text{label})$};
    \node [block, right of = genbeddings, xshift= 4.5cm]  (comp) {\shortstack{Vector\\Comparison}};
    \node [right of = comp, xshift = 2cm]  (end) {$\delta(T_1[i].\text{label}, T_2[j].\text{label})$};


    % Draw edges
    \draw [->] (t1.east)  -| ($(t1)!0.5!(genbeddings)$) coordinate |-(genbeddings);
    \draw [->] (t2.east)  -| ($(t2)!0.5!(genbeddings)$) coordinate |-(genbeddings);
    \draw [->] (genbeddings.east)  -| ($(genbeddings)!0.5!(et1)$) coordinate |-(et1);
    \draw [->] (genbeddings.east)  -| ($(genbeddings)!0.5!(et2)$) coordinate |-(et2);
    \draw [->] (et1.east)  -| ($(et1)!0.5!(comp)$) coordinate |-(comp);
    \draw [->] (et2.east)  -| ($(et2)!0.5!(comp)$) coordinate |-(comp);
    \draw [->] (comp)  -- (end);
\end{tikzpicture}
\caption{Process of calculating the distance between two node labels.}
\label{fig:semanticreplacement}
\end{figure*}




% One approach would be to ignore labels entirely and attempt to perform a tree edit comparison purely based on the structure of attack trees. This would be akin to setting the cost of replacement to 0. However, there is an additional issue as the Zhang and Shasha algorim relies on an initial mapping of like nodes between the two trees, a mapping done primarily based on labels. In order to ignore labels and define an edit distance based on tree structure alone, we would need to perform such a mapping based on the placement of nodes within the tree. Such a mapping would be possible

% , and would .  While this may yield interesting results, it can result in two trees being evaluated with an edit distance of 0 while not at all being similar (as they are structurally the same). A small example is provided in Figure~\NS{Add fig} where the two trees are structurally equivalent, and all that is needed to edit one tree to another would be to replace all nodes. If the cost of replacement is 0, then the edit distance between the two trees is likewise 0. 




\subsection{Semantic similarity}







% After performing this mapping step, we compute tree edit distance as described by Zhang and Shasha. However, the cost of replacing a node with another node is given as 1 - semantic similarity. In this way, nodes that have highly similar labels (a semantic similarity approaching 1) will have a low replacement cost, while those with little to no semantic similarity will have high replacement cost. Additionally, if we give that the cost of adding or removing a node to be 1, we prime the Zhang and Shasha algorithm to attempt to replace as many nodes as possible. \NS{this may not be a good thing}

\subsection{Semantic replacement}

The second use of semantic similarity is in the Zhang and Shasha replacement operation. In the provided algorithm, a label is comparison is made between the root nodes of two trees when calculating the cost of replacements. If the root node labels are the same, the cost of replacement is given as 0; otherwise the cost is given as 1. We adjust this label comparison by applying a semantic distance comparison.

We calculate the semantic embeddings for each node label, and compare the result embeddings. If the semantic similarity is above a given threshold, $\epsilon$, we give the cost of replacement to be 0; otherwise, we give the cost of replacement to be 1. This allows for the Zhang and Shasha algorithm to replace nodes with similar labels at a lower cost than nodes with dissimilar labels.

When we examine the forest distance equation from Zhang and Shasha~\cite{zhang_simple_1989}, we see the cost of replacing a given node as
% \begin{equation*}
\begin{align*}
    \text { forestdist } & \left(l\left(i_1\right) . . l(i)-1, l\left(j_1\right) . . l(j)-1\right) \\
                         & + \text { forestdist }(l(i) \ldots i-1, l(j) . . j-1)                   \\
                         & + \gamma\left(T_1[i] \rightarrow T_2[j]\right)
\end{align*}
% \end{equation*}


We give the $\gamma\left(T_1[i].\text{label} \rightarrow T_2[j].\text{label}\right)$ to be the following:

\begin{equation*}
    \gamma\left(T_1[i].\text{label} \rightarrow T_2[j].\text{label}\right)=\left\{\begin{array}{ll}
        0, & \text { if } \delta\left(T_1[i].\text{label}, T_2[j].\text{label}\right)>\epsilon \\
        1, & \text { otherwise }
    \end{array}\right.
\end{equation*}




% \begin{equation*}
%     \text { forestdist }\left(l\left(i_1\right) \ldots i, l\left(j_1\right) . . j\right)=\min \left\{\begin{array}{l}
%         \text { forestdist }\left(l\left(i_1\right) \ldots i-1, l\left(j_1\right) . . j\right)+\gamma\left(T_1[i] \rightarrow \Lambda\right), \\
%         \text { forestdist }\left(l\left(i_1\right) . . i, l\left(j_1\right) . . j-1\right)+\gamma\left(\Lambda \rightarrow T_2[j]\right),    \\
%         \text { forestdist }\left(l\left(i_1\right) . . l(i)-1, l\left(j_1\right) . . l(j)-1\right)                                           \\
%         + \text { forestdist }(l(i) \ldots i-1, l(j) . . j-1)                                                                                 \\
%         +\gamma\left(T_1[i] \rightarrow T_2[j]\right) .
%     \end{array}\right.
% \end{equation*}

Selecting the $\epsilon$ value will ultimately depend on the context in which this comparison is used.If $\epsilon$ is too lowe, then the cost of replacemenst will be 0 for all nodes, and the tree edit distance will be purely based on the structure of the treesa as all replacement operations will have no cost. If $\epsilon$ is too high, then the cost of replacement will be 1 for all nodes, and the tree edit distance will be identical to the original Zhang and Shasha algorithm (with all replacement operations having a cost of 1). In Figure~\ref{img:similaritylimits}, we show the average distance between the 38 experimental ATs per semantic similarity limit. We see that as the semantic similarity limit increases, the average distance between the trees increases, as the cost of all replacement operations slowly move toward 1. We discuss this further in Section~\ref{sec:results}